{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"The Power of Data Simulation\"\n",
        "subtitle: \"Using Python's NumPy Random Generator to Model Randomness & Build Intuition\"\n",
        "author: \"Russ Zaliznyak <[rzaliznyak@gmail.com](mailto:rzaliznyak@gmail.com)>\"\n",
        "date: \"2024-11-04\"\n",
        "execute:\n",
        "  echo: false\n",
        "format: \n",
        "  html: \n",
        "    css: style.css\n",
        "    toc: true\n",
        "    toc-expand: true\n",
        "    toc-indent: 1em\n",
        "jupyter: python3\n",
        "---\n",
        "\n",
        "\n",
        "\n",
        "# Introduction\n",
        "\n",
        "Simulating data is an indispensable tool in the business and data science community. It offers a cost-effective way to model complex relationships and rare events within datasets, enabling the exploration of various scenarios without real-world consequences.\n",
        "\n",
        "Simulations can facilitate the measurement of competing methods' performance on shared datasets and assess how statistical models perform when the ground truth is known. This helps to refine analytical methodologies and even support training of machine learning models in the absence of real data.\n",
        "\n",
        "Using website conversion as our example, we are going to simulate huge datasets and build our intuition for the randomness we might expect to see. By the end of this paper, you'll be able to model randomness and analyze results for rate-based metrics on your own.\n",
        "\n",
        "# Website Conversion Example\n",
        "\n",
        "Imagine your website converts 10% of its visitors to paying customers. Over the course of 10,000 visitors, how many converts should we expect? A quick back of the envelope calculation shows we should expect 1,000 conversions:\n",
        "$$\n",
        "10000 \\, \\text{visitors} * \\frac{10 \\, \\text{conversions}}{100 \\, \\text{visitors}} = 1000 \\, \\text{conversions}\n",
        "$$\n",
        "\n",
        "\n",
        "_How much could that number vary on any given day?_\n",
        "\n",
        "# Simulating Data\n",
        "Let's simulate the process of website conversion 1,000,000x with n = 10,000 and p = 0.10 (conversion rate).\n"
      ],
      "id": "9c88a2ab"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-fold: false\n",
        "#| echo: true\n",
        "import timeit\n",
        "from numpy.random import binomial, seed\n",
        "seed(10)\n",
        "\n",
        "conversion_rate = 0.10\n",
        "number_of_visitors = int(1e4)\n",
        "\n",
        "\n",
        "start = timeit.default_timer()\n",
        "number_simulated_experiments = int(1e6)\n",
        "control_simulated_results = binomial(\n",
        "    number_of_visitors, conversion_rate, size=number_simulated_experiments\n",
        ")\n",
        "stop = timeit.default_timer()\n",
        "print(f\"simulation runtime: {round(stop-start,3)} secs\")\n"
      ],
      "id": "c5c8e849",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Graph Simulation Results\n",
        "\n",
        "At the end of each simulation, we record and plot how many conversions took place. Each panel represents the results of plotting more simulations together.\n",
        "\n",
        "Our first simulation generated only `{python} control_simulated_results[0]` conversions. But with enough simulations plotted together, are you seeing a pattern develop?\n"
      ],
      "id": "2c40d0c5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: fig-one-plot\n",
        "#| fig-cap: 'Histograms of the aforementioned simulations. With enougn simulations, it''s possible to see website conversion forms a predictable pattern.'\n",
        "#| code-fold: true\n",
        "#| echo: true\n",
        "\n",
        "import plotly.subplots as sp\n",
        "import pandas as pd\n",
        "import plotly.express as px\n",
        "from math import ceil\n",
        "from numpy import where, linspace, min, max, cumsum, percentile, array, mean\n",
        "\n",
        "\n",
        "df = pd.DataFrame(control_simulated_results, columns=[\"value\"])\n",
        "running_total_df = df.copy()\n",
        "\n",
        "# Count occurrences and create a running total\n",
        "running_total_df[\"count\"] = running_total_df[\"value\"].map(\n",
        "    running_total_df[\"value\"].value_counts()\n",
        ")\n",
        "running_total_df[\"running_total\"] = running_total_df.groupby(\"value\").cumcount() + 1\n",
        "\n",
        "# Rearranging to match the running total of occurrences\n",
        "running_total_df = running_total_df[[\"value\", \"count\", \"running_total\"]]\n",
        "\n",
        "\n",
        "\n",
        "number_experiments_list = [\n",
        "    1,\n",
        "    50,\n",
        "    200,\n",
        "    400,\n",
        "    800,\n",
        "    2500,\n",
        "    int(1e4),\n",
        "    int(1e5),\n",
        "]\n",
        "subplot_titles = tuple([f\"# sims = {value}\" for value in number_experiments_list])\n",
        "number_experiments_list_length = len(number_experiments_list)\n",
        "\n",
        "\n",
        "number_cols = 4\n",
        "number_rows = ceil(number_experiments_list_length / number_cols)\n",
        "BLUE = \"#82b2e0\"\n",
        "RED = \"#bd0707\"\n",
        "fig = sp.make_subplots(\n",
        "    rows=number_rows,\n",
        "    cols=number_cols,\n",
        "    subplot_titles=subplot_titles,\n",
        "    vertical_spacing=0.1,\n",
        ")\n",
        "\n",
        "for j in range(len(number_experiments_list)):\n",
        "    number = number_experiments_list[j]\n",
        "    fig_0 = px.scatter(\n",
        "        running_total_df[0:number],\n",
        "        x=\"value\",\n",
        "        y=\"running_total\",\n",
        "        color_discrete_sequence = [BLUE]\n",
        "    )\n",
        "    \n",
        "\n",
        "    row = 1 + int(j / number_cols)\n",
        "    col = 1 + j - (row - 1) * number_cols\n",
        "    fig.add_trace(fig_0.data[0], row=row, col=col)\n",
        "\n",
        "\n",
        "x_ticks = [950, 1000, 1050]\n",
        "for j in range(len(number_experiments_list)):\n",
        "    row = 1 + int(j / number_cols)\n",
        "    col = 1 + j - (row - 1) * number_cols\n",
        "\n",
        "    fig.update_xaxes(\n",
        "        #tickvals=x_ticks if j > 0 else [int(df[\"value\"].iloc[0])], row=row, col=col\n",
        "    )\n",
        "\n",
        "fig.update_layout(height=600, hovermode=False)\n",
        "fig.show()"
      ],
      "id": "fig-one-plot",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "<!--\n",
        "The cumulative distribution function (CDF) is defined as:\n",
        "$$\n",
        "P(X \\leq k) = \\sum_{i=0}^{k} \\binom{n}{i} p^i (1-p)^{n-i}\n",
        "$$\n",
        "-->\n",
        "\n",
        "\n",
        "## Use Simulation Results to Estimate Randomness \n",
        "\n",
        "1. What's the chance of 950 conversions or fewer?\n",
        "2. What's the chance of 1050 conversions or more?\n",
        "3. What's the chance of between 950 and 1050 conversions (exclusive)?\n"
      ],
      "id": "71571250"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-fold: true\n",
        "#| echo: false\n",
        "#| label: fig-two-plot\n",
        "#| fig-cap: The red area is the share of simulations falling into the given range.\n",
        "import plotly.graph_objecgrts as go\n",
        "from scipy import stats\n",
        "\n",
        "standard_error = (conversion_rate*(1-conversion_rate)/number_of_visitors)**0.5\n",
        "BLUE = \"#0177c9\"\n",
        "RED = \"#bd0707\"\n",
        "number_points = 250\n",
        "pdf = stats.gaussian_kde(control_simulated_results)\n",
        "X = linspace(\n",
        "    min(control_simulated_results), max(control_simulated_results), number_points\n",
        ")\n",
        "estimated_density = pdf.evaluate(X)\n",
        "cumulative_density = cumsum(estimated_density)\n",
        "cumulative_density /= cumulative_density[-1]\n",
        "cdf_list = list(cumulative_density)\n",
        "fx_list = estimated_density\n",
        "\n",
        "hover_string = \"True Baseline\"\n",
        "is_rate = False\n",
        "text_list = [\n",
        "    f\"Pr( {hover_string} > { round((100 if is_rate else 1)*X[j],3 if is_rate else 2) }{'%' if is_rate else ''}) = {'{0:.2%}'.format(1 - cdf_list[j])}\"\n",
        "    for j in range(len(X))\n",
        "]\n",
        "distribution_titles = (\n",
        "        \"950 conversions or less\",\n",
        "        \"1050 conversions or more\",\n",
        "        \"Between 950 and 1050 conversions\",\n",
        "    )\n",
        "distribution_figure = sp.make_subplots(\n",
        "    rows=1,\n",
        "    cols=3,\n",
        "    subplot_titles=distribution_titles,\n",
        "    vertical_spacing=0.1,\n",
        ")\n",
        "\n",
        "lower_bound_list = [950, None, 950]\n",
        "upper_bound_list = [None, 1050, 1050]\n",
        "\n",
        "\n",
        "line_color_left = BLUE\n",
        "line_color_right = BLUE\n",
        "probability_list = []\n",
        "for j in range(3):\n",
        "    lower_bound_position = 0\n",
        "    upper_bound_position = number_points - 1\n",
        "    lower_bound = lower_bound_list[j]\n",
        "    upper_bound = upper_bound_list[j]\n",
        "\n",
        "    if lower_bound is not None:\n",
        "        lower_bound_position = where(array(X) > lower_bound)[0][0]\n",
        "    if upper_bound is not None:\n",
        "        upper_bound_position = where(array(X) > upper_bound)[0][0]\n",
        "\n",
        "    prob = None\n",
        "    probability = None\n",
        "    if lower_bound is not None and upper_bound is not None:\n",
        "        line_color_left = BLUE\n",
        "        line_color_right = BLUE\n",
        "        prob = mean(\n",
        "            where(\n",
        "                (control_simulated_results > lower_bound)\n",
        "                & (control_simulated_results < upper_bound),\n",
        "                1,\n",
        "                0,\n",
        "            )\n",
        "        )\n",
        "        x_axis_title = f\"{prob:.2%} of outcomes shaded\"\n",
        "        probability = stats.norm.cdf(\n",
        "            upper_bound / number_of_visitors, loc=conversion_rate, scale=standard_error\n",
        "        ) - stats.norm.cdf(\n",
        "            lower_bound / number_of_visitors, loc=conversion_rate, scale=standard_error\n",
        "        )\n",
        "    elif lower_bound is not None and upper_bound is None:\n",
        "        line_color_left = RED\n",
        "        prob = mean(where(control_simulated_results <= lower_bound, 1, 0))\n",
        "        x_axis_title = f\"{prob:.2%} of outcomes shaded\"\n",
        "\n",
        "        probability = stats.norm.cdf(\n",
        "            lower_bound / number_of_visitors, loc=conversion_rate, scale=standard_error\n",
        "        )\n",
        "    elif upper_bound is not None and lower_bound is None:\n",
        "        line_color_right = RED\n",
        "        prob = mean(where(control_simulated_results >= upper_bound, 1, 0))\n",
        "        x_axis_title = f\"{prob:.2%} of outcomes shaded\"\n",
        "        probability = 1 - stats.norm.cdf(\n",
        "            upper_bound / number_of_visitors, loc=conversion_rate, scale=standard_error\n",
        "        )\n",
        "    else:\n",
        "        pass\n",
        "    probability_list.append(probability)\n",
        "    x_axis_title = f\"{prob:.2%} of outcomes shaded\" if prob is not None else None\n",
        "\n",
        "    line_color_middle = RED if line_color_left == BLUE else BLUE\n",
        "    distribution_figure.add_trace(\n",
        "        go.Scatter(\n",
        "            x=X[0:lower_bound_position],\n",
        "            y=fx_list[0:lower_bound_position],\n",
        "            hoverinfo=\"skip\",\n",
        "            # marker_symbol=\"square\",\n",
        "            name=\"< 0 \",\n",
        "            marker=dict(size=50),\n",
        "            showlegend=False,\n",
        "            line_color=line_color_left,\n",
        "            # hovertext=text_list[:positive_position],\n",
        "            # fill = \"blue\",\n",
        "            line=dict(width=0.05),\n",
        "            stackgroup=\"1\",\n",
        "        ),\n",
        "        row=1,\n",
        "        col=j + 1,\n",
        "    )\n",
        "    distribution_figure.add_trace(\n",
        "        go.Scatter(\n",
        "            x=X[lower_bound_position:upper_bound_position],\n",
        "            y=fx_list[lower_bound_position:upper_bound_position],\n",
        "            hoverinfo=\"skip\",\n",
        "            # marker_symbol=\"square\",\n",
        "            name=\"< 0 \",\n",
        "            marker=dict(size=50),\n",
        "            showlegend=False,\n",
        "            line_color=line_color_middle,\n",
        "            # hovertext=text_list[:positive_position],\n",
        "            # fill = \"blue\",\n",
        "            line=dict(width=0.05),\n",
        "            stackgroup=\"1\",\n",
        "        ),\n",
        "        row=1,\n",
        "        col=j + 1,\n",
        "    )\n",
        "    distribution_figure.add_trace(\n",
        "        go.Scatter(\n",
        "            x=X[upper_bound_position:],\n",
        "            y=fx_list[upper_bound_position:],\n",
        "            hoverinfo=\"skip\",\n",
        "            # marker_symbol=\"square\",\n",
        "            name=\"< 0 \",\n",
        "            marker=dict(size=50),\n",
        "            showlegend=False,\n",
        "            line_color=line_color_right,\n",
        "            # hovertext=text_list[:positive_position],\n",
        "            # fill = \"blue\",\n",
        "            line=dict(width=0.05),\n",
        "            stackgroup=\"1\",\n",
        "        ),\n",
        "        row=1,\n",
        "        col=j + 1,\n",
        "    )\n",
        "    distribution_figure.add_trace(\n",
        "        go.Scatter(\n",
        "            x=X,\n",
        "            y=fx_list,\n",
        "            hoverinfo=\"text\",\n",
        "            # fill='tozeroy',\n",
        "            mode=\"lines\",\n",
        "            # name = \"+\" ,\n",
        "            showlegend=False,\n",
        "            line_color=\"black\",\n",
        "            hovertext=text_list,\n",
        "            line=dict(width=1.5),\n",
        "        ),\n",
        "        row=1,\n",
        "        col=j + 1,\n",
        "    )\n",
        "\n",
        "    distribution_figure.update_xaxes(\n",
        "        title_text=x_axis_title,\n",
        "        row=1,\n",
        "        col=j + 1,\n",
        "    )\n",
        "\n",
        "\n",
        "tick_values = [950, 1000, 1050]\n",
        "\n",
        "distribution_figure.update_xaxes(\n",
        "    zeroline=False,\n",
        "    tickangle=0,\n",
        "    # title = \"\" if x_axis_title is None else x_axis_title,\n",
        "    tickvals=tick_values,\n",
        "    title_font=dict(size=12),\n",
        "    ticks=\"inside\",  # Default is 'outside'\n",
        "    ticklen=6,\n",
        ")\n",
        "distribution_figure.update_yaxes(\n",
        "    title=\"\",\n",
        "    visible=False,\n",
        "    showticklabels=False,\n",
        ")\n",
        "distribution_figure.update_traces(hoverlabel=dict(font=dict(size=18)))\n",
        "\n",
        "\n",
        "distribution_figure.update_layout(height=300)\n",
        "distribution_figure.update_layout(\n",
        "    annotations=[\n",
        "        dict(\n",
        "            text=\"950 conversions or less\",\n",
        "            x=0.15,\n",
        "            y=1.05,\n",
        "            font=dict(size=12),\n",
        "            showarrow=False,\n",
        "        ),\n",
        "        dict(\n",
        "            text=\"1050 conversions or more\",\n",
        "            x=0.5,\n",
        "            y=1.05,\n",
        "            font=dict(size=12),\n",
        "            showarrow=False,\n",
        "        ),\n",
        "        dict(\n",
        "            text=\"Between 950 and 1050 conversions\",\n",
        "            x=0.85,\n",
        "            y=1.05,\n",
        "            font=dict(size=12),\n",
        "            showarrow=False,\n",
        "        ),\n",
        "    ]\n",
        ")\n",
        "\n",
        "\n",
        "distribution_figure.show()"
      ],
      "id": "fig-two-plot",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Once you've simulated your dataset, it is _**effortless**_ to calculate these probabilities!!!\n"
      ],
      "id": "f20f0d6a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-fold: false\n",
        "#| echo: true\n",
        "prob = mean(\n",
        "    where(\n",
        "        (control_simulated_results > 950)\n",
        "        & (control_simulated_results < 1050),\n",
        "        1,\n",
        "        0,\n",
        "    )\n",
        ")\n",
        "print(f\"{prob:.2%}\")"
      ],
      "id": "162a9f67",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Verify Simulation Results\n",
        "\n",
        "Because Rate-based metrics are normally distributed, we can use the normal approximation to verify our simulation results are reasonable using mean = `{python} conversion_rate` and standard_error = `{python} f\"({conversion_rate}\"` * `{python} f\"{1 - conversion_rate})/sqrt(10,000)\"`.\n",
        "\n",
        "$$\n",
        "F(0.095) = \\Phi\\left( \\frac{0.095 - 0.10}{0.003} \\right) = \\Phi\\left( -1.67 \\right) = 0.0478\n",
        "$$\n"
      ],
      "id": "aae7b6e9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# | code-fold: true\n",
        "# | echo: false\n",
        "import pandas as pd\n",
        "\n",
        "probability_list = [f\"{value:.2%}\" for value in probability_list]\n",
        "df = pd.DataFrame({\"Type\":distribution_titles, \"Probability\": probability_list})\n",
        "print(df)"
      ],
      "id": "81d76c6f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Slight differences are explained by the continuous nature of the normal approximation. Our data is discrete.\n",
        "\n",
        "\n",
        "# Conclusion\n",
        "\n",
        "By simulating 1MM simulations for our website conversion example, we were able to observe patterns and trends that might be difficult or costly to capture in real-world scenarios. For now, you should have learned how to use NumPy to generate rate-based simulated data and how to interpret the results.\n",
        "\n",
        "This approach will prove even more valuable when dealing with problems that lack closed-form analytical solutions. \n",
        "We will demonstrate this utility in future topics when we expand our use of NumPy to model more complex AB Testing topics like:\n",
        "\n",
        "- [**Experiment Design & Analysis with NumPy Random**: Understanding P-values and Statistical Power with NumPy Simulations](https://rzaliznyak-math.github.io/numpy-random-examples/){target=\"_blank\"}.\n",
        "- Continuous Metrics\n",
        "- Sequential & Bayesian Testing\n",
        "- Using Prior Information to Improve Effect Size Estimates\n",
        "- CUPED: Using Covariates to Reduce Experimentation Run-time\n",
        "\n",
        "# Acknowledgements\n",
        "\n",
        "Big THANK YOU to my colleague Joseph Powers, PhD, who introduced me to _Quarto_ and using simulation studies to make my work life easier."
      ],
      "id": "00e6615f"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/Users/rzaliznyak/anaconda3/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}